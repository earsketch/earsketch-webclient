// Play DAW projects generated by user scripts
import { DAWData } from "common"
import { ProjectGraph, clearAudioGraph, playTrack } from "./common"
import context from "./context"
import esconsole from "../esconsole"
import { TempoMap } from "../app/tempo"
import { dbToFloat } from "./utils"

let isPlaying = false

const timers = {
    playStart: 0,
    playEnd: 0,
}

let playbackData = {
    waStartTime: 0,
    startMeasure: 1,
    endMeasure: 1,
    playheadPos: 1,
    startOffset: 0,
}

let loop = {
    on: false,
    selection: false,
    start: 0,
    end: 0,
}

let dawData: DAWData | null = null

let upcomingProjectGraph: ProjectGraph | null = null
let projectGraph: ProjectGraph | null = null

let mutedTracks: number[] = []
let bypassedEffects: { [key: number]: string[] } = {}

const out = context.createGain()

const reset = () => {
    esconsole("resetting", ["player", "debug"])
    pause()
    playbackData = {
        waStartTime: 0,
        startMeasure: 1,
        endMeasure: 1,
        playheadPos: 1,
        startOffset: 0,
    }
}

const clearAllTimers = () => {
    clearTimeout(timers.playStart)
    clearTimeout(timers.playEnd)
}

export interface TrackGraph {
    clips: AudioBufferSourceNode[]
    effects: { [key: string]: any }
    output: GainNode
}

export function play(startMes: number, endMes: number, manualOffset = 0) {
    esconsole("starting playback", ["player", "debug"])

    // init / convert
    if (loop.on && loop.selection) {
        // startMes = loop.start
        endMes = loop.end
    }

    if (dawData === null) {
        esconsole("null in render queue", ["player", "error"])
        return
    }

    const tempoMap = new TempoMap(dawData)
    const startTime = tempoMap.measureToTime(startMes)
    const endTime = tempoMap.measureToTime(endMes)

    const waStartTime = context.currentTime + manualOffset

    // construct webaudio graph
    if (upcomingProjectGraph) clearAudioGraph(upcomingProjectGraph)
    upcomingProjectGraph = {
        tracks: [],
        mix: new GainNode(context),
    }

    for (let t = 0; t < dawData.tracks.length; t++) {
        // skip muted tracks
        if (mutedTracks.includes(t)) continue
        // get the list of bypassed effects for this track
        const trackBypass = bypassedEffects[t] ?? []
        const trackGraph = playTrack(context, t, dawData.tracks[t], out, tempoMap, startTime, endTime, waStartTime, upcomingProjectGraph.mix, trackBypass)
        upcomingProjectGraph.tracks.push(trackGraph)
    }

    // set flags
    clearTimeout(timers.playStart)
    timers.playStart = window.setTimeout(() => {
        if (loop.on) {
            if (loop.selection) {
                playbackData.startOffset = startMes > loop.start ? startMes - loop.start : 0
                playbackData.startMeasure = loop.start
                playbackData.endMeasure = loop.end
            } else {
                playbackData.startOffset = startMes - 1
                playbackData.startMeasure = 1
                playbackData.endMeasure = dawData!.length + 1
            }
        } else {
            playbackData.startOffset = 0
            playbackData.startMeasure = startMes
            playbackData.endMeasure = endMes
        }

        esconsole("recording playback data: " + [startMes, endMes].toString(), ["player", "debug"])
        if (projectGraph) clearAudioGraph(projectGraph)
        projectGraph = upcomingProjectGraph
        upcomingProjectGraph = null
        playbackData.waStartTime = waStartTime
        isPlaying = true
        callbacks.onStartedCallback()
        if (loop.on) {
            const timeElapsed = context.currentTime - waStartTime
            play(playbackData.startMeasure, playbackData.endMeasure, endTime - startTime - timeElapsed)
        }
    }, manualOffset * 1000)

    // schedule to call the onFinished callback
    clearTimeout(timers.playEnd)
    timers.playEnd = window.setTimeout(() => {
        esconsole("playbackTimer ended", "player")
        reset()
        callbacks.onFinishedCallback()
    }, (endTime - startTime + manualOffset) * 1000)
}

export function pause() {
    esconsole("pausing", ["player", "debug"])
    clearAllAudioGraphs()
    clearAllTimers()
    isPlaying = false
}

const clearAllAudioGraphs = (delay = 0) => {
    esconsole("clearing the audio graphs", ["player", "debug"])
    if (projectGraph) clearAudioGraph(projectGraph, delay)
    if (upcomingProjectGraph) clearAudioGraph(upcomingProjectGraph, delay)
}

const refresh = () => {
    if (isPlaying) {
        esconsole("refreshing the rendering data", ["player", "debug"])
        const currentMeasure = getPosition()
        const nextMeasure = Math.floor(currentMeasure + 1)
        const tempoMap = new TempoMap(dawData!)
        const timeTillNextBar = tempoMap.measureToTime(nextMeasure) - tempoMap.measureToTime(currentMeasure)

        console.assert(projectGraph)
        clearAudioGraph(projectGraph!, timeTillNextBar)

        play(nextMeasure, playbackData.endMeasure, timeTillNextBar)
    }
}

// Set playback volume in decibels.
export const setVolume = (gain: number) => {
    esconsole("Setting context volume to " + gain + "dB", ["DEBUG", "PLAYER"])
    out.gain.setValueAtTime(dbToFloat(gain), context.currentTime)
}

export const setLoop = (loop_: typeof loop) => {
    loop = loop_
    esconsole("setting loop: " + loop.on, ["player", "debug"])
    if (!isPlaying) return

    clearAllTimers()

    const tempoMap = new TempoMap(dawData!)
    const currentMeasure = getPosition()
    const currentTime = tempoMap.measureToTime(currentMeasure)

    if (loop.on) {
        if (loop.selection) {
            if (currentMeasure >= loop.start && currentMeasure < loop.end) {
                if (currentMeasure < loop.end - 1) {
                    play(Math.ceil(currentMeasure), loop.end, tempoMap.measureToTime(Math.floor(currentMeasure + 1)) - currentTime)
                } else {
                    play(loop.start, loop.end, tempoMap.measureToTime(loop.end) - currentTime)
                }
            } else {
                play(loop.start, loop.end, tempoMap.measureToTime(Math.floor(currentMeasure + 1)) - currentTime)
            }
        } else {
            play(1, dawData!.length + 1, tempoMap.measureToTime(dawData!.length + 1) - currentTime)
        }
    } else if (currentMeasure < playbackData.endMeasure && playbackData.endMeasure <= (dawData!.length + 1)) {
        clearTimeout(timers.playStart)
        clearTimeout(timers.playEnd)
        // User switched off loop while playing.
        // Because we were playing a loop, we didn't schedule anything after the loop end.
        // Now there's no loop, so we need to schedule everything from [end of old loop] to [end of project].
        const timeTillContinuedPoint = tempoMap.measureToTime(playbackData.endMeasure) - currentTime
        play(playbackData.endMeasure, dawData!.length + 1, timeTillContinuedPoint)
    }
}

export const setRenderingData = (result: DAWData) => {
    esconsole("setting new rendering data", ["player", "debug"])
    dawData = result
    if (isPlaying) {
        refresh()
    }
}

export function setPosition(position: number) {
    esconsole("setting position: " + position, ["player", "debug"])

    clearAllTimers()

    if (isPlaying) {
        let endMeasure = playbackData.endMeasure
        if (loop.on) {
            if (loop.selection) {
                endMeasure = loop.end
            } else {
                endMeasure = dawData!.length + 1
            }
        }

        const currentMeasure = getPosition()
        const nextMeasure = Math.floor(currentMeasure + 1)
        const tempoMap = new TempoMap(dawData!)
        const timeTillNextBar = tempoMap.measureToTime(nextMeasure) - tempoMap.measureToTime(currentMeasure)
        if (projectGraph) clearAudioGraph(projectGraph, timeTillNextBar)
        play(position, endMeasure, timeTillNextBar)
    } else {
        playbackData.playheadPos = position
    }
}

export const getPosition = () => {
    if (isPlaying) {
        const tempoMap = new TempoMap(dawData!)
        const startTime = tempoMap.measureToTime(playbackData.startMeasure + playbackData.startOffset)
        const currentTime = startTime + (context.currentTime - playbackData.waStartTime)
        playbackData.playheadPos = tempoMap.timeToMeasure(currentTime)
    }
    return playbackData.playheadPos
}

export const setMutedTracks = (_mutedTracks: number[]) => {
    mutedTracks = _mutedTracks

    if (isPlaying) {
        refresh()
    }
}

export const setBypassedEffects = (_bypassedEffects: { [key: number]: string[] }) => {
    bypassedEffects = _bypassedEffects

    if (isPlaying) {
        refresh()
    }
}

export const callbacks = {
    onStartedCallback: () => {},
    onFinishedCallback: () => {},
}
